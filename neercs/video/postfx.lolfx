-- GLSL.Vert --

#version 120

void main()
	{
	gl_Position=gl_Vertex;
	gl_TexCoord[0]=gl_MultiTexCoord0;
	}

-- GLSL.Frag --

#version 120

uniform sampler2D texture;
uniform vec2 screen_size;
uniform float time;
uniform vec2 deform;
uniform vec4 ghost;
uniform vec3 filter;
uniform vec3 color;
uniform vec3 retrace;
uniform vec2 offset;
uniform float noise;
uniform float aberration;
uniform vec4 moire_h;
uniform vec4 moire_v;
uniform vec4 scanline_h;
uniform vec4 scanline_v;
uniform vec2 corner;
uniform float flash;
uniform float sync;

const float PI=3.14159265358979323846;

vec2 screen(in vec2 p,in float radius)
	{
	float d=deform.x+sync*0.0625;
	return p*(1.5-(radius*cos(p.x*d)+radius*cos(p.y*d)))-0.5;
	}

vec3 get_color(in sampler2D tex,in vec2 p)
	{
	return texture2D(tex,clamp(p,-1.0,0.0)).xyz;
	}

float rand(in vec2 p)
	{
	return fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453);
	}

float letterbox(in vec2 p,in float radius,in float smooth)
	{
	return 1.0-smoothstep(smooth,1.0,length(max(abs(p*2.0+1.0)-vec2(radius),0.0))+radius);
	}

void main(void)
	{
	vec2 q=gl_FragCoord.xy/screen_size.xy;
	vec2 p=-1.0+2.0*gl_FragCoord.xy/screen_size.xy;
	p.y+=0.025*sync;
	vec2 z =screen(p,deform.y);
	vec2 z1=screen(p,deform.y-ghost.x*0.1);
	vec2 z2=screen(p,deform.y+ghost.z*0.1);
	float mask=q.x*(6.0-q.x*6.0)*q.y*(6.0-q.y*6.0);

	vec2 rnd=vec2(rand(vec2(p.x+time,p.y-time)),rand(vec2(p.x-time,p.y+time)));

	vec2 o=(offset-offset*2.0*rnd.x)/screen_size;			// offset
	vec3 source=get_color(texture,z+o);						// offset added to source
	vec3 glass1=get_color(texture,z1);
	vec3 glass2=get_color(texture,z2);

	float v=aberration/float(screen_size.x)+aberration/float(screen_size.x)*(2.0-mask);

	vec3 ca;
	ca.x=get_color(texture,vec2(z.x+o.x-v,z.y+o.y)).x;
	ca.y=get_color(texture,vec2(z.x+o.x  ,z.y+o.y)).y;
	ca.z=get_color(texture,vec2(z.x+o.x+v,z.y+o.y)).z;

	vec3 c=source-glass1*glass1*ghost.y+glass2*glass2*ghost.w;

	float a=(c.x+c.y+c.z)/3.0;
	vec3 g=vec3(a,a,a);
	c=mix(c,g,color.z);										// gray
	c*=filter;												// filter
	c*=color.x;												// brightness
	c=0.5+(c-0.5)*color.y;									// contrast

	c+=flash;												// flash
	c+=ca;													// chromatic aberration
	c-=retrace.x*mod(z.y*retrace.y+time*retrace.z,1.0);		// retrace
	c-=(vec3(rnd.x-rnd.y))*noise;							// noise
	c*=moire_h.x+moire_h.y*sin(z.y*float(screen_size.y*moire_h.z))*sin(0.5+z.x*float(screen_size.x*moire_h.w));	// moire h
	c*=moire_v.x+moire_v.y*sin(z.x*float(screen_size.x*moire_v.z))*sin(0.5+z.y*float(screen_size.y*moire_v.w));	// moire v
	c*=scanline_h.x+scanline_h.y*cos(z.y*float(screen_size.y*scanline_h.z+scanline_h.w));	// scanline h
	c*=scanline_v.x+scanline_v.y*cos(z.x*float(screen_size.x*scanline_v.z+scanline_v.w));	// scanline v
	c*=mask;												// vignetting
	c*=letterbox(z,corner.x,corner.y);						// letterbox
	gl_FragColor=vec4(c,1.0);
	}