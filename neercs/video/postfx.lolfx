-- GLSL.Vert --

#version 120

void main()
	{
	gl_Position=gl_Vertex;
	gl_TexCoord[0]=gl_MultiTexCoord0;
	}

-- GLSL.Frag --

#version 120

uniform sampler2D texture;
uniform vec2 screen_size;
uniform float time;
uniform float deform;
uniform vec3 filter;
uniform vec3 retrace;
uniform vec2 offset;
uniform float noise;
uniform float aberration;
uniform bool moire;
uniform vec4 moire_h;
uniform vec4 moire_v;
uniform bool scanline;
uniform vec4 scanline_h;
uniform vec4 scanline_v;
uniform float flash;
uniform float sync;

const float PI=3.14159265358979323846;

vec2 zoom(in vec2 p,in float radius)
	{
	float d=deform+sync*0.0625;
	float zoom=1.5-(radius*cos(p.x*d)+radius*cos(p.y*d));
	return p*zoom-0.5;
	}

vec3 get_color(in sampler2D tex,in vec2 p)
	{
	return texture2D(tex,clamp(p,-1.0,0.0)).xyz;
	}

float rand(in vec2 p)
	{
	return fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453);
	}

float letterbox(in vec2 p,in float radius,in float smooth)
	{
	return 1.0-smoothstep(smooth,1.0,length(max(abs(p*2.0+1.0)+vec2(radius),0.0))-radius);
	}

void main(void)
	{
	vec2 q=gl_FragCoord.xy/screen_size.xy;
	vec2 p=-1.0+2.0*gl_FragCoord.xy/screen_size.xy;
	p.y+=0.025*sync;
	vec2 z =zoom(p,0.5250);
	vec2 z1=zoom(p,0.5225);
	vec2 z2=zoom(p,0.5275);
	float mask=q.x*(6.0-q.x*6.0)*q.y*(6.0-q.y*6.0);

	vec2 rnd=vec2(rand(vec2(p.x+time,p.y-time)),rand(vec2(p.x-time,p.y+time)));

	vec2 o=(offset-offset*2.0*rnd.x)/screen_size;					// offset
	vec3 source=get_color(texture,z+o);								// offset added to source
	vec3 glass1=get_color(texture,z1);
	vec3 glass2=get_color(texture,z2);

	float v=aberration/float(screen_size.x)+aberration/float(screen_size.x)*(2.0-mask);

	vec3 ca;
	ca.x=get_color(texture,vec2(z.x+o.x-v,z.y+o.y)).x;
	ca.y=get_color(texture,vec2(z.x+o.x  ,z.y+o.y)).y;
	ca.z=get_color(texture,vec2(z.x+o.x+v,z.y+o.y)).z;

	vec3 color=source+glass1*glass1*0.25+glass2*glass2*0.25;

	color=smoothstep(0.05,1.0,color);
	color+=flash;													// flash
	color+=ca;														// chromatic aberration
	color-=retrace.x*mod(z.y*retrace.y+time*retrace.z,1.0);			// retrace
	color-=(vec3(rnd.x-rnd.y))*noise;								// noise
	if(moire)
		{
		color*=moire_h.x+moire_h.y*sin(z.y*float(screen_size.y*moire_h.z))*sin(0.5+z.x*float(screen_size.x*moire_h.w));	// moire h
		color*=moire_v.x+moire_v.y*sin(z.x*float(screen_size.x*moire_v.z))*sin(0.5+z.y*float(screen_size.y*moire_v.w));	// moire v
		}
	else
		{
		color*=(moire_h.x+moire_v.x)*0.5;
		}
	if(scanline)
		{
		color*=scanline_h.x+scanline_h.y*cos(z.y*float(screen_size.y*scanline_h.z+scanline_h.w));	// scanline h
		color*=scanline_v.x+scanline_v.y*cos(z.x*float(screen_size.x*scanline_v.z+scanline_v.w));	// scanline v
		}
	else
		{
		color*=(scanline_h.x+scanline_v.x)*0.5;
		}
	color*=filter;													// filter
	color*=mask;													// vignetting
	color*=letterbox(z,-0.75,0.95);									// letnoiseterbox
	gl_FragColor=vec4(color,1.0);
	}